# coding: utf-8

"""
    ConnectWise PSA

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2022.2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional, Union
from pydantic import BaseModel, StrictBool, StrictFloat, StrictInt
from pydantic import Field
from connectwise_psa.models.agreement_application_aviable_per import AgreementApplicationAviablePer
from connectwise_psa.models.agreement_application_billing_cycle import AgreementApplicationBillingCycle
from connectwise_psa.models.agreement_application_limit import AgreementApplicationLimit
from connectwise_psa.models.agreement_application_unit import AgreementApplicationUnit
from connectwise_psa.models.user_defined_field_value_model import UserDefinedFieldValueModel
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class AgreementApplicationParameters(BaseModel):
    """
    AgreementApplicationParameters
    """ # noqa: E501
    agr_billing_cycle: Optional[AgreementApplicationBillingCycle] = Field(default=None, alias="agrBillingCycle")
    agreement_expires_flag: Optional[StrictBool] = Field(default=None, alias="agreementExpiresFlag")
    allow_overruns_flag: Optional[StrictBool] = Field(default=None, alias="allowOverrunsFlag")
    application_limit: Optional[AgreementApplicationLimit] = Field(default=None, alias="applicationLimit")
    application_limit_amount: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="applicationLimitAmount")
    application_unit: Optional[AgreementApplicationUnit] = Field(default=None, alias="applicationUnit")
    available_per: Optional[AgreementApplicationAviablePer] = Field(default=None, alias="availablePer")
    carry_over_days: Optional[StrictInt] = Field(default=None, alias="carryOverDays")
    carryover_unused_flag: Optional[StrictBool] = Field(default=None, alias="carryoverUnusedFlag")
    charge_adjustments_flag: Optional[StrictBool] = Field(default=None, alias="chargeAdjustmentsFlag")
    covers_expenses_flag: Optional[StrictBool] = Field(default=None, alias="coversExpensesFlag")
    covers_products_flag: Optional[StrictBool] = Field(default=None, alias="coversProductsFlag")
    covers_tax_flag: Optional[StrictBool] = Field(default=None, alias="coversTaxFlag")
    covers_time_flag: Optional[StrictBool] = Field(default=None, alias="coversTimeFlag")
    overrun_limit: Optional[StrictInt] = Field(default=None, alias="overrunLimit")
    prepay_flag: Optional[StrictBool] = Field(default=None, alias="prepayFlag")
    user_defined_field_values: Optional[List[UserDefinedFieldValueModel]] = Field(default=None, alias="userDefinedFieldValues")
    __properties: ClassVar[List[str]] = ["agrBillingCycle", "agreementExpiresFlag", "allowOverrunsFlag", "applicationLimit", "applicationLimitAmount", "applicationUnit", "availablePer", "carryOverDays", "carryoverUnusedFlag", "chargeAdjustmentsFlag", "coversExpensesFlag", "coversProductsFlag", "coversTaxFlag", "coversTimeFlag", "overrunLimit", "prepayFlag", "userDefinedFieldValues"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of AgreementApplicationParameters from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of agr_billing_cycle
        if self.agr_billing_cycle:
            _dict['agrBillingCycle'] = self.agr_billing_cycle.to_dict()
        # override the default output from pydantic by calling `to_dict()` of application_limit
        if self.application_limit:
            _dict['applicationLimit'] = self.application_limit.to_dict()
        # override the default output from pydantic by calling `to_dict()` of application_unit
        if self.application_unit:
            _dict['applicationUnit'] = self.application_unit.to_dict()
        # override the default output from pydantic by calling `to_dict()` of available_per
        if self.available_per:
            _dict['availablePer'] = self.available_per.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in user_defined_field_values (list)
        _items = []
        if self.user_defined_field_values:
            for _item in self.user_defined_field_values:
                if _item:
                    _items.append(_item.to_dict())
            _dict['userDefinedFieldValues'] = _items
        # set to None if carry_over_days (nullable) is None
        # and model_fields_set contains the field
        if self.carry_over_days is None and "carry_over_days" in self.model_fields_set:
            _dict['carryOverDays'] = None

        # set to None if overrun_limit (nullable) is None
        # and model_fields_set contains the field
        if self.overrun_limit is None and "overrun_limit" in self.model_fields_set:
            _dict['overrunLimit'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of AgreementApplicationParameters from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        # raise errors for additional fields in the input
        for _key in obj.keys():
            if _key not in cls.__properties:
                raise ValueError("Error due to additional fields (not defined in AgreementApplicationParameters) in the input: " + _key)

        _obj = cls.model_validate({
            "agrBillingCycle": AgreementApplicationBillingCycle.from_dict(obj.get("agrBillingCycle")) if obj.get("agrBillingCycle") is not None else None,
            "agreementExpiresFlag": obj.get("agreementExpiresFlag"),
            "allowOverrunsFlag": obj.get("allowOverrunsFlag"),
            "applicationLimit": AgreementApplicationLimit.from_dict(obj.get("applicationLimit")) if obj.get("applicationLimit") is not None else None,
            "applicationLimitAmount": obj.get("applicationLimitAmount"),
            "applicationUnit": AgreementApplicationUnit.from_dict(obj.get("applicationUnit")) if obj.get("applicationUnit") is not None else None,
            "availablePer": AgreementApplicationAviablePer.from_dict(obj.get("availablePer")) if obj.get("availablePer") is not None else None,
            "carryOverDays": obj.get("carryOverDays"),
            "carryoverUnusedFlag": obj.get("carryoverUnusedFlag"),
            "chargeAdjustmentsFlag": obj.get("chargeAdjustmentsFlag"),
            "coversExpensesFlag": obj.get("coversExpensesFlag"),
            "coversProductsFlag": obj.get("coversProductsFlag"),
            "coversTaxFlag": obj.get("coversTaxFlag"),
            "coversTimeFlag": obj.get("coversTimeFlag"),
            "overrunLimit": obj.get("overrunLimit"),
            "prepayFlag": obj.get("prepayFlag"),
            "userDefinedFieldValues": [UserDefinedFieldValueModel.from_dict(_item) for _item in obj.get("userDefinedFieldValues")] if obj.get("userDefinedFieldValues") is not None else None
        })
        return _obj


